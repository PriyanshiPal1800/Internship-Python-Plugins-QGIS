# -*- coding: utf-8 -*-
"""
/***************************************************************************
 Multipart
                                 A QGIS plugin
 Divide the polygon into multiple parts
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2023-03-26
        git sha              : $Format:%H$
        copyright            : (C) 2023 by Priyanshi Pal
        email                : priyakusum2000@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication,QVariant
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction,QFileDialog
from qgis.core import QgsVectorLayer,QgsProject,QgsPolygon, QgsMultiPolygon,QgsField,QgsFeature,QgsWkbTypes,QgsGeometry,QgsPalLayerSettings,QgsVectorLayerSimpleLabeling,QgsVectorDataProvider
from qgis.utils import iface
from shapely.geometry import mapping, shape
from shapely.ops import unary_union


import processing 
# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .Multipart_dialog import MultipartDialog
import os.path
import geopandas as gpd
import utm


class Multipart:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'Multipart_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&Multipart')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('Multipart', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = f'{self.plugin_dir}/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u''),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&Multipart'),
                action)
            self.iface.removeToolBarIcon(action)

    def inputlayer(self):
        global filename
        filename, _filter = QFileDialog.getOpenFileName(
        self.dlg, "Select Input text file ","", '*.shp')
        self.dlg.inputlineEdit.setText(filename)

        #################################################  changing datatype #####################################################

        gdf = gpd.read_file(filename)

        # Change the data type of a column
        gdf['ID1'] = gdf['ID1'].astype(str)

        # Write the updated GeoDataFrame to a new shapefile
        gdf.to_file(filename)
        

        # create the polygon layer

        QgsProject.instance().clear()
        filename = self.dlg.inputlineEdit.text()
        orignalfile = QgsVectorLayer(filename, "all plots", "ogr")
        QgsProject.instance().addMapLayer(orignalfile)
        layer = iface.activeLayer()

        vlayer=iface.activeLayer()
        vlayer.selectAll()
        mCanvas = iface.mapCanvas()
        mCanvas.zoomToSelected()
        vlayer.removeSelection()

        # Display plot Ids on the polygon layer- Label 

        for layer in QgsProject.instance().mapLayers().values():
            layer_settings  = QgsPalLayerSettings()
            layer_settings.fieldName = "ID1"
            layer_settings.enabled = True
            layer_settings = QgsVectorLayerSimpleLabeling(layer_settings)
            layer.setLabelsEnabled(True)
            layer.setLabeling(layer_settings)
            layer.triggerRepaint()
        
        # adding plot No. to dropdown list
        idx = layer.dataProvider().fieldNameIndex( 'ID1' ) 
        uv = layer.dataProvider().uniqueValues( idx )
        
        uv1=[str(x) for x in uv]
        uv1.sort()
        self.dlg.selectComboBox.addItems(uv1)

    def Upload_Point_Layer2(self):

        layerList = QgsProject.instance().mapLayersByName("all plots")
        layer=layerList[0]
        global id2
        id2=self.dlg.selectComboBox.currentText()
        
        filename = self.dlg.inputlineEdit.text()
        
        gdf = gpd.read_file(filename)
        features = layer.getFeatures()
        # getting the points from polygon layer for selected plot
            
        layer=iface.activeLayer() 
        gdf = gpd.read_file(filename)
        features = layer.getFeatures()
        global id1,mypolygon1
        for feat in features:
            if(feat['ID1']==id2):
                id1=feat.id()                
                mypolygon1=gdf.loc[int(id1),'geometry']                
                break

        qgs_geometry = QgsGeometry.fromWkt(mypolygon1.wkt)

        # create a new memory layer with a polygon geometry
        layer = QgsVectorLayer('Polygon?crs=EPSG:4326', 'mypolygon', 'memory')
        pr = layer.dataProvider()

        # create a new feature with the polygon geometry
        feature = QgsFeature()
        feature.setGeometry(qgs_geometry)

        # add the feature to the layer
        pr.addFeatures([feature])
        layer.updateExtents()

        # add the layer to the map
        QgsProject.instance().addMapLayer(layer)
        
        canvas = iface.mapCanvas()
        canvas.setExtent(layer.extent())
        canvas.refresh()



        
    
    

    def run(self):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
            self.dlg = MultipartDialog()
            self.dlg.inputpushButton.clicked.connect(self.inputlayer)
            self.dlg.confirmpushButton.clicked.connect(self.Upload_Point_Layer2)

        # show the dialog
        self.dlg.show()
        # Run the dialog event loop
        result = self.dlg.exec_()
        # See if OK was pressed
        if result:
            # Do something useful here - delete the line containing pass and
            # substitute with your code.
            n=self.dlg.plotlineEdit.text()
            print(n)
            #### EDIT INPUTS BELOW ####
            # provide the path of the polygon below
            POLYPATH = filename
            # spacing of regular points
            SPACING_REG = 50.0
            # number of divisions
            N_DIV = int(n)
            # provide the folder to save the resulting polygons
            OUTLOC =' E:\SEM 3\Internship\F_input'
            OUTPOLYGONS = OUTLOC+'62divided_'
            # coordinate system
            CRS_PTS = 'EPSG:32645'

            #################################################
            #try:
                # open polygon
            # poly_qgs = QgsVectorLayer(POLYPATH, 'single_polygon', 'ogr')
            # QgsProject.instance().addMapLayers([poly_qgs])
            poly_qgs=iface.activeLayer()
            # extent of the polygon
            extentrect=poly_qgs.extent()
            xmax = extentrect.xMaximum()
            ymax = extentrect.yMaximum()
            xmin = extentrect.xMinimum()
            ymin = extentrect.yMinimum()
            extentreg=str(xmin) + ',' + str(xmax) + ','+ str(ymin)+ ',' + str(ymax)
            # extract the vertices of the polygon
            paramextract = {'INPUT': poly_qgs, 'OUTPUT': 'memory:'}
            polyvertices = processing.run("native:extractvertices", paramextract)
            QgsProject.instance().addMapLayers([polyvertices['OUTPUT']])
            # clustering
            paramcluster = {'CLUSTERS': N_DIV, 'FIELD_NAME': 'CLUSTER_ID', 'INPUT': polyvertices['OUTPUT'], 'OUTPUT': 'memory:', 'SIZE_FIELD_NAME': 'CLUSTER_SIZE'}
            verticesclusters = processing.run("native:kmeansclustering", paramcluster)#temp
            # mean coordinates
            parammean = {'INPUT': verticesclusters['OUTPUT'], 'OUTPUT': 'memory:', 'UID': 'CLUSTER_ID', 'WEIGHT': ''}
            verticesmean = processing.run("native:meancoordinates", parammean)
            QgsProject.instance().addMapLayers([verticesmean['OUTPUT']])
            # voronoi polygons
            paramvoro = {'BUFFER': 100, 'INPUT': verticesmean['OUTPUT'], 'OUTPUT': 'memory:'}
            voronoi_poly = processing.run("qgis:voronoipolygons", paramvoro)
            QgsProject.instance().addMapLayers([voronoi_poly['OUTPUT']])
            # clip voronoi polygons by the original polygon
            #paramclip = {'INPUT': voronoi_poly['OUTPUT'], 'OVERLAY': poly_qgs, 'outputpoly': OUTPOLYGONS}
            

            
            
            #################################### display the polygon ################################################################3333
            # layer 1
            layerList = QgsProject.instance().mapLayersByName("all plots")
            layer=layerList[0]
            gdf = gpd.read_file(filename)
            features = layer.getFeatures()
            for feat in features:
                if(feat['ID1']==id2):
                    id1=feat.id()                
                    mypolygon1=gdf.loc[int(id1),'geometry']                
                    break
                
            # Convert shapely polygon to QgsGeometry object
            qgs_geometry = QgsGeometry.fromWkt(mypolygon1.wkt)

            # layer 2
            #layers = QgsProject.instance().mapLayersByName('outputpoly')
            output=iface.activeLayer()
            # create an empty list to store the resulting polygons
            intersected_polygons = []

            # loop through each feature in the output layer
            for feat in output.getFeatures():
                # extract the geometry of the feature
                poly = feat.geometry()

                # find the intersection between the polygon and the polygon layer
                intersection = poly.intersection(qgs_geometry)
                # if the intersection is a polygon, append it to the list
                intersected_polygons.append(intersection)


                

            # create a new layer containing the intersected polygons
            new_layer = QgsVectorLayer("MultiPolygon?crs=EPSG:32645", "Intersected Polygons", "memory")
            prov = new_layer.dataProvider()
            feat_list = [QgsFeature() for i in range(len(intersected_polygons))]
            for i, poly in enumerate(intersected_polygons):
                feat_list[i].setGeometry(poly)
                print(poly.area())
            prov.addFeatures(feat_list)
            new_layer.updateExtents()

            QgsProject.instance().addMapLayer(new_layer)

            ########################### add new plots to F_80 ###################################################################

            layerList = QgsProject.instance().mapLayersByName("all plots")
            layer=layerList[0]
            
            i=1
            field_names = [field.name() for field in layer.fields()]
            
            

            r=1
            prov = layer.dataProvider()
            feat_list = [QgsFeature() for i in range(len(intersected_polygons))]
            
            for i, poly in enumerate(intersected_polygons):
                l=[]
                for field in field_names:
                
                    if(field=='ID1'):
                        l.append(str(id2+'/'+str(r)))
                        
                    else:
                        l.append(0)
                print(r)
                print(l)
                r+=1
                print(r)
                feat_list[i].setGeometry(poly)
                feat_list[i].setAttributes(l)
                print(poly.area())
            prov.addFeatures(feat_list)
            layer.updateExtents()

            caps=layer.dataProvider().capabilities()
            
            dfeats=[]
            # creating point layer for selected plot
        

            if caps & QgsVectorDataProvider.DeleteFeatures:
                print("id")
                print(id1)
                dfeats.append(id1)
                res=layer.dataProvider().deleteFeatures(dfeats)


            ################################################### deleting the output layers ######################################
            # layers = QgsProject.instance().mapLayersByName('output')
            # QgsProject.instance().removeMapLayer(layers[0])
            # layers = QgsProject.instance().mapLayersByName('output')
            # QgsProject.instance().removeMapLayer(layers[0])
            # layers = QgsProject.instance().mapLayersByName('output')
            # QgsProject.instance().removeMapLayer(layers[0])
            # layers = QgsProject.instance().mapLayersByName('mypolygon')
            # QgsProject.instance().removeMapLayer(layers[0])



            xc=[]
            yc=[]
            lat=[]
            lon=[]
            c1=[]
            g=[]
            gdf = gpd.read_file(filename)
            layer_provider=layer.dataProvider()
            abc=layer.fields().names()
            l=len(abc)
            a=abc.count('Xcentroid')

            flag=0
            features = layer.getFeatures()
            for feat in features:
                id=feat.id()
                mypolygon1=gdf.loc[id,'geometry']
                try:
                    c=list(mypolygon1.centroid.coords)
                except:
                    flag+=1
                g.append(mypolygon1)
                xc.append(c[0][0])
                yc.append(c[0][1])

            if a==0 :
                layer_provider.addAttributes([QgsField("Xcentroid",QVariant.String)])
                layer_provider.addAttributes([QgsField("Ycentroid",QVariant.String)])
                layer_provider.addAttributes([QgsField("Latitude",QVariant.String)])
                layer_provider.addAttributes([QgsField("Longitude",QVariant.String)])
                layer_provider.addAttributes([QgsField("unique id",QVariant.String)])
                layer_provider.addAttributes([QgsField("Multipolygon",QVariant.String)])
                g=[]
                layer.updateFields()
                layer.startEditing()
                features = layer.getFeatures()
                
                for feat in features:
                    id=feat.id()
                    mypolygon1=gdf.loc[id,'geometry']
                    try:
                        c=list(mypolygon1.centroid.coords)
                    except:
                        flag+=1
                    a1={l:str(c[0][0])}
                    a2={l+1:str(c[0][1])}
                    g.append(mypolygon1)
                    xc.append(c[0][0])
                    yc.append(c[0][1])
                    layer_provider.changeAttributeValues({id:a1})
                    layer_provider.changeAttributeValues({id:a2})
                    h=utm.to_latlon(xc[id], yc[id], 45, 'N')
                    lat.append(h[0])
                    lon.append(h[1])
                    code=pniUgenerator(h[0],h[1],0)
                    c1.append(code)
                    lat1=str(lat[id])
                    a3={l+2:lat1}
                    lon1=str(lon[id])
                    a4={l+3:lon1}
                    a5={l+4:c1[id]}
                    a6={l+5:str(gdf.loc[id,'geometry'])}
                    layer_provider.changeAttributeValues({id:a3})
                    layer_provider.changeAttributeValues({id:a4})
                    layer_provider.changeAttributeValues({id:a5})
                    layer_provider.changeAttributeValues({id:a6})
                    
                layer.commitChanges()  
            else:
                r=0
                r1=0
                l=abc.index('Xcentroid')
                for i, poly in enumerate(intersected_polygons):
                    r+=1
                    layer.updateFields()
                    layer.startEditing()
                    features = layer.getFeatures()
                    for feat in features:
                        if(feat['ID1']==str(id2+'/'+str(r))):
                            id=feat.id()
                            mypolygon1=gdf.loc[id,'geometry']
                            try:
                                c=list(mypolygon1.centroid.coords)
                            except:
                                flag+=1
                            a1={l:str(c[0][0])}
                            a2={l+1:str(c[0][1])}
                            g.append(mypolygon1)
                            xc.append(c[0][0])
                            yc.append(c[0][1])
                            layer_provider.changeAttributeValues({id:a1})
                            layer_provider.changeAttributeValues({id:a2})
                            h=utm.to_latlon(xc[id], yc[id], 45, 'N')
                            lat.append(h[0])
                            lon.append(h[1])
                            code=pniUgenerator(h[0],h[1],0)
                            c1.append(code)
                            lat1=str(lat[r1])
                            a3={l+2:lat1}
                            lon1=str(lon[r1])
                            a4={l+3:lon1}
                            a5={l+4:c1[r1]}
                            a6={l+5:str(gdf.loc[id,'geometry'])}
                            layer_provider.changeAttributeValues({id:a3})
                            layer_provider.changeAttributeValues({id:a4})
                            layer_provider.changeAttributeValues({id:a5})
                            layer_provider.changeAttributeValues({id:a6})
                            layer.commitChanges()
                            r1+=1



def dec_to_base(num,base):  
    base_num = ""
    while num>0:
        dig = int(num%base)
        if dig<10:
            base_num += str(dig)
        else:
            base_num += chr(ord('A')+dig-10) 
        num //= base
    base_num = base_num[::-1]  
    return base_num
    
def pniUgenerator(latitude,longitude,f):
  lat = str(latitude)
  splitLat = lat.split(".")
  splitLat[0] = splitLat[0].ljust( 2, "0")
  splitLat[1] = splitLat[1].rjust(6, "0")
  lat1 = int(splitLat[0])
  lat1 += 90
  lat1= dec_to_base(lat1,14)
  slat1 = (str(lat1)).upper()
  slat1=slat1.ljust(2,"0")
  slat1 = slat1.replace("I", "Y")
  slat1 = slat1.replace("O", "Z")
  lat2 = int(splitLat[1][:3])
  lat2=dec_to_base(lat2,32)
  slat2 =(str(lat2)).upper()
  slat2=slat2.ljust(2,"0")
  slat2 = slat2.replace("I", "Y")
  slat2 = slat2.replace("O", "Z")
  lat3 = int(splitLat[1][3:6])
  lat3=dec_to_base(lat3,32)
  slat3 = (str(lat3)).upper()
  slat3=slat3.ljust(2,"0")
  slat3 = slat3.replace("I", "Y")
  slat3 = slat3.replace("O", "Z")
  lon=str(longitude)
  splitLon=lon.split(".")
  splitLon[0] = splitLon[0].ljust( 2, "0")
  splitLon[1] =splitLon[1].rjust( 6, "0")
  lon1 = int(splitLon[0])
  lon1 += 180
  lon1=dec_to_base(lon1,19)
  slon1 = (str(lon1)).upper()
  slon1 = slon1.replace("I", "Y")
  slon1 = slon1.replace("O", "Z")
  lon2 = int(splitLon[1][0:3])
  lon2 = dec_to_base(lon2, 32)
  slon2=(str(lon2)).upper()
  slon2=slon2.ljust(2,"0")
  slon2 = slon2.replace("I", "Y")
  slon2 = slon2.replace("O", "Z")
  lon3 = int(splitLon[1][3:6])
  lon3=dec_to_base(lon3,32)
  slon3 = (str(lon3)).upper()
  slon3 = slon3.ljust(2,"0")
  slon3 = slon3.replace("I", "Y")
  slon3 = slon3.replace("O", "Z")
  f1 = f + 578
  f1 = dec_to_base(f1, 34)
  f2= (str(f1)).upper()
  f2 =f2.ljust(2,"0")
  f2 = f2.replace("I", "Y")
  f2 = f2.replace("O", "Z")
  pniU=slat1+slat2+slat3+"-"+slon1+slon2+slon3+"-"+f2
  return(pniU)

